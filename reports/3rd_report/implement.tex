\section{Implementation}
The implementation to solve problem 3 was built upon that we had implemented in the previous two iterations. Handling attributes of the algorighm, meta information of the data and transformations of the data itself was mainly the reused components. Additionally the apriori algorithm for sequences is the same than that used for frequent itemsets. Our new implementation consist of two main parts: the candidate generation and the support counting. We also implemented a sub-sequence detection method, which is beneficial for our support counting. The implemented algorithm mainly follows instructions in chapter 7, Association Analysis: Advanced Concepts of the book Introduction to Data Mining by Tan,Steinbach, and Kumar.\\ 

The candidate generation follows the pseudocode in chapter 7, Association Analysis: Advanced Concepts of the book Introduction to Data Mining by Tan, Steinbach, and Kumar. The code adapts the Apriori principle, a bottom up approach to find frequent sets, so that it  can handel sequential data instead of just sets. Therefor it is an Apriori-like algorithm for sequential pattern discovery.\\
Our implementation of the candidate generation takes advantage of alphabetically ordered eventsts inside the elements, this avoids unnecessary compraisons and  improves the running time. We also prune infrequent sequences based on the contiguoius {k-1}-sequences.\\

The support counting is implemented in a brute force manner while using the subsequence detection method. The subsequence detection method is a brute force approach with some optimizations. As sequences are sorted, we do not have to go through them every time, but we can terminate the search if the next character in the event of a subsequence is smaller than the next character of supersequence’s event. Additionally if the max-gap is provided, we terminate the search, once we reach the gap count.\\

The status of implementation:\\
\begin{center}
\begin{tabular}{|c|c|}
\hline Value&Yes\\
\hline Min gap&No\\
\hline Max gap&Yes\\
\hline Max span&No\\
\hline Window size&No\\
\hline
\end{tabular}
\end{center}

The reason for implementing max gap was possible need for optimizations. THe algorithm could be faster 
with a max gap that is large enough not to affect the results. The most interesting feature 
that was not implemented is window size, because it might have a major effect on 
the results.

\subsection{Candidate generation}
The data mining book is a bit unclear about sequence candidate generation. There is no pseudo code for that -- only a brief description. When coding what the book says, the result is not working, because it will never produce $2$-seuqneces of form $\langle\{a,b\}\rangle$. And therefore there won't be any sequences with an element of a size greater than $1$. This problem was removed by generating $1$- and $2$-sequences differently from the book. Other sequences is generated in the way the book represents.\\ 

The code adapts the modified apriori principle 7.3 of the book. This is required to avoid problems, when max gap is used. Each $k$-sequence candidate is generated by merging two $\{k-1\}$.sequences $s$ and $t$, when removing the first event from $s$ and last event from $t$ produces equal sequences. This needed that we defined the order of events inside the elements.

\subsection{Support counting}
The support counting is implemented in a brute force manner, while using the subsequence detection method. The subsequence detection method is a brute force approach with some optimizations. As events are ordered, we do not have to go through them all, but we can terminate the search if the next item in the element of a subsequence is smaller than the next item of supersequence’s element. Additionally, if the max gap is provided, we terminate the search once we reach the gap count.

\subsection{Rule generation}
In addition to the algorithm the book gave us, we added a kind of rule generation from sequences. It has the same idea than generating rules from frequent itemsets, but it is much more easier, because of the order is already specified.
